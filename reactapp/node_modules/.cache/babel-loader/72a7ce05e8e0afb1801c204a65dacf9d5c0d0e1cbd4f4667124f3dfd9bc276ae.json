{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = exports.BaseServer = void 0;\nconst qs = require(\"querystring\");\nconst url_1 = require(\"url\");\nconst base64id = require(\"base64id\");\nconst transports_1 = require(\"./transports\");\nconst events_1 = require(\"events\");\nconst socket_1 = require(\"./socket\");\nconst debug_1 = require(\"debug\");\nconst cookie_1 = require(\"cookie\");\nconst ws_1 = require(\"ws\");\nconst webtransport_1 = require(\"./transports/webtransport\");\nconst util_1 = require(\"util\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nconst TEXT_DECODER = new util_1.TextDecoder();\nfunction parseSessionId(handshake) {\n  if (handshake.startsWith(\"0{\")) {\n    try {\n      const parsed = JSON.parse(handshake.substring(1));\n      if (typeof parsed.sid === \"string\") {\n        return parsed.sid;\n      }\n    } catch (e) {}\n  }\n}\nclass BaseServer extends events_1.EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} opts - options\n   * @api public\n   */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.middlewares = [];\n    this.clients = {};\n    this.clientsCount = 0;\n    this.opts = Object.assign({\n      wsEngine: ws_1.Server,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: [\"polling\", \"websocket\"],\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        // @ts-ignore\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n    if (this.opts.cors) {\n      this.use(require(\"cors\")(this.opts.cors));\n    }\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n    this.init();\n  }\n  /**\n   * Compute the pathname of the requests that are handled by the server\n   * @param options\n   * @protected\n   */\n  _computePath(options) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n    if (options.addTrailingSlash !== false) {\n      // normalize path\n      path += \"/\";\n    }\n    return path;\n  }\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports_1.default[transport].upgradesTo || [];\n  }\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n    if (!~this.opts.transports.indexOf(transport) || transport === \"webtransport\") {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, {\n        transport\n      });\n    }\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    }\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n      if (transport === \"websocket\" && !upgrade) {\n        debug(\"invalid transport upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\"\n        });\n      }\n      if (!this.opts.allowRequest) return fn();\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n        fn();\n      });\n    }\n    fn();\n  }\n  /**\n   * Adds a new middleware.\n   *\n   * @example\n   * import helmet from \"helmet\";\n   *\n   * engine.use(helmet());\n   *\n   * @param fn\n   */\n  use(fn) {\n    this.middlewares.push(fn);\n  }\n  /**\n   * Apply the middlewares to the request.\n   *\n   * @param req\n   * @param res\n   * @param callback\n   * @protected\n   */\n  _applyMiddlewares(req, res, callback) {\n    if (this.middlewares.length === 0) {\n      debug(\"no middleware to apply, skipping\");\n      return callback();\n    }\n    const apply = i => {\n      debug(\"applying middleware n°%d\", i + 1);\n      this.middlewares[i](req, res, err => {\n        if (err) {\n          return callback(err);\n        }\n        if (i + 1 < this.middlewares.length) {\n          apply(i + 1);\n        } else {\n          callback();\n        }\n      });\n    };\n    apply(0);\n  }\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    this.cleanup();\n    return this;\n  }\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  generateId(req) {\n    return base64id.generateId();\n  }\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api protected\n   */\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    debug('handshaking client \"%s\"', id);\n    try {\n      var transport = this.createTransport(transportName, req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new socket_1.Socket(id, this, transport, req, protocol);\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n          // @ts-ignore\n          (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n    transport.onRequest(req);\n    this.clients[id] = socket;\n    this.clientsCount++;\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n    this.emit(\"connection\", socket);\n    return transport;\n  }\n  async onWebTransportSession(session) {\n    const timeout = setTimeout(() => {\n      debug(\"the client failed to establish a bidirectional stream in the given period\");\n      session.close();\n    }, this.opts.upgradeTimeout);\n    const streamReader = session.incomingBidirectionalStreams.getReader();\n    const result = await streamReader.read();\n    if (result.done) {\n      debug(\"session is closed\");\n      return;\n    }\n    const stream = result.value;\n    const reader = stream.readable.getReader();\n    // reading the first packet of the stream\n    const {\n      value,\n      done\n    } = await reader.read();\n    if (done) {\n      debug(\"stream is closed\");\n      return;\n    }\n    clearTimeout(timeout);\n    const handshake = TEXT_DECODER.decode(value);\n    // handshake is either\n    // \"0\" => new session\n    // '0{\"sid\":\"xxxx\"}' => upgrade\n    if (handshake === \"0\") {\n      const transport = new webtransport_1.WebTransport(session, stream, reader);\n      // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n      const id = base64id.generateId();\n      debug('handshaking client \"%s\" (WebTransport)', id);\n      const socket = new socket_1.Socket(id, this, transport, null, 4);\n      this.clients[id] = socket;\n      this.clientsCount++;\n      socket.once(\"close\", () => {\n        delete this.clients[id];\n        this.clientsCount--;\n      });\n      this.emit(\"connection\", socket);\n      return;\n    }\n    const sid = parseSessionId(handshake);\n    if (!sid) {\n      debug(\"invalid WebTransport handshake\");\n      return session.close();\n    }\n    const client = this.clients[sid];\n    if (!client) {\n      debug(\"upgrade attempt for closed client\");\n      session.close();\n    } else if (client.upgrading) {\n      debug(\"transport has already been trying to upgrade\");\n      session.close();\n    } else if (client.upgraded) {\n      debug(\"transport had already been upgraded\");\n      session.close();\n    } else {\n      debug(\"upgrading existing transport\");\n      const transport = new webtransport_1.WebTransport(session, stream, reader);\n      client.maybeUpgrade(transport);\n    }\n  }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */\nBaseServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\nclass WebSocketResponse {\n  constructor(req, socket) {\n    this.req = req;\n    this.socket = socket;\n    // temporarily store the response headers on the req object (see the \"headers\" event)\n    req[kResponseHeaders] = {};\n  }\n  setHeader(name, value) {\n    this.req[kResponseHeaders][name] = value;\n  }\n  getHeader(name) {\n    return this.req[kResponseHeaders][name];\n  }\n  removeHeader(name) {\n    delete this.req[kResponseHeaders][name];\n  }\n  write() {}\n  writeHead() {}\n  end() {\n    // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n    this.socket.destroy();\n  }\n}\nclass Server extends BaseServer {\n  /**\n   * Initialize websocket server\n   *\n   * @api protected\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n    if (this.ws) this.ws.close();\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = req[kResponseHeaders] || {};\n        delete req[kResponseHeaders];\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n        this.emit(\"headers\", additionalHeaders, req);\n        debug(\"writing headers: %j\", additionalHeaders);\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n  cleanup() {\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n  }\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n    }\n  }\n  createTransport(transportName, req) {\n    return new transports_1.default[transportName](req);\n  }\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {IncomingMessage} req\n   * @param {ServerResponse} res\n   * @api public\n   */\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    // @ts-ignore\n    req.res = res;\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n      // @ts-ignore\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        // @ts-ignore\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n        // @ts-ignore\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n    const res = new WebSocketResponse(req, socket);\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n      const head = Buffer.from(upgradeHead);\n      upgradeHead = null;\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      res.writeHead();\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    };\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n    if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n    // get client id\n    const id = req._query.sid;\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n        const transport = this.createTransport(req._query.transport, req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  attach(server) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const path = this._computePath(options);\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n    function check(req) {\n      // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n      return path === req.url.slice(0, path.length);\n    }\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function () {\n            // @ts-ignore\n            if (socket.writable && socket.bytesWritten <= 0) {\n              socket.on(\"error\", e => {\n                debug(\"error while destroying upgrade: %s\", e.message);\n              });\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message\n  }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\nfunction abortUpgrade(socket, errorCode) {\n  let errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n  socket.destroy();\n}\n/* eslint-disable */\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Server","BaseServer","qs","require","url_1","base64id","transports_1","events_1","socket_1","debug_1","cookie_1","ws_1","webtransport_1","util_1","debug","default","kResponseHeaders","Symbol","TEXT_DECODER","TextDecoder","parseSessionId","handshake","startsWith","parsed","JSON","parse","substring","sid","e","EventEmitter","constructor","opts","arguments","length","undefined","middlewares","clients","clientsCount","assign","wsEngine","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","transports","allowUpgrades","httpCompression","threshold","cors","allowEIO3","cookie","name","path","httpOnly","sameSite","use","perMessageDeflate","init","_computePath","options","replace","addTrailingSlash","upgrades","transport","upgradesTo","verify","req","upgrade","fn","_query","indexOf","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","hasOwnProperty","UNKNOWN_SID","previousTransport","method","BAD_HANDSHAKE_METHOD","allowRequest","message","success","FORBIDDEN","push","_applyMiddlewares","res","callback","apply","i","err","close","cleanup","generateId","transportName","closeConnection","protocol","EIO","emit","code","UNSUPPORTED_PROTOCOL_VERSION","errorMessages","context","id","error","createTransport","b64","supportsBinary","socket","Socket","on","isInitialRequest","serialize","onRequest","once","onWebTransportSession","session","timeout","setTimeout","streamReader","incomingBidirectionalStreams","getReader","result","read","done","stream","reader","readable","clearTimeout","decode","WebTransport","client","upgrading","upgraded","maybeUpgrade","WebSocketResponse","setHeader","getHeader","removeHeader","write","writeHead","end","destroy","ws","noServer","clientTracking","maxPayload","headersArray","additionalHeaders","keys","forEach","key","prepare","url","query","handleRequest","errorCode","errorContext","abortRequest","handleUpgrade","upgradeHead","abortUpgrade","head","Buffer","from","websocket","onWebSocket","onUpgradeError","prototype","handlesUpgrades","removeListener","attach","server","destroyUpgradeTimeout","check","slice","listeners","removeAllListeners","bind","l","call","destroyUpgrade","writable","bytesWritten","statusCode","stringify","byteLength","validHdrChars","val","charCodeAt"],"sources":["/home/priyanshu/Desktop/rebook/main/reactapp/node_modules/engine.io/build/server.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Server = exports.BaseServer = void 0;\nconst qs = require(\"querystring\");\nconst url_1 = require(\"url\");\nconst base64id = require(\"base64id\");\nconst transports_1 = require(\"./transports\");\nconst events_1 = require(\"events\");\nconst socket_1 = require(\"./socket\");\nconst debug_1 = require(\"debug\");\nconst cookie_1 = require(\"cookie\");\nconst ws_1 = require(\"ws\");\nconst webtransport_1 = require(\"./transports/webtransport\");\nconst util_1 = require(\"util\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nconst TEXT_DECODER = new util_1.TextDecoder();\nfunction parseSessionId(handshake) {\n    if (handshake.startsWith(\"0{\")) {\n        try {\n            const parsed = JSON.parse(handshake.substring(1));\n            if (typeof parsed.sid === \"string\") {\n                return parsed.sid;\n            }\n        }\n        catch (e) { }\n    }\n}\nclass BaseServer extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(opts = {}) {\n        super();\n        this.middlewares = [];\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: [\"polling\", \"websocket\"],\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024,\n            },\n            cors: false,\n            allowEIO3: false,\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\",\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.use(require(\"cors\")(this.opts.cors));\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024,\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Compute the pathname of the requests that are handled by the server\n     * @param options\n     * @protected\n     */\n    _computePath(options) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        if (options.addTrailingSlash !== false) {\n            // normalize path\n            path += \"/\";\n        }\n        return path;\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     * @api public\n     */\n    upgrades(transport) {\n        if (!this.opts.allowUpgrades)\n            return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n    verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n        if (!~this.opts.transports.indexOf(transport) ||\n            transport === \"webtransport\") {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin,\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid,\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport,\n                });\n            }\n        }\n        else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method,\n                });\n            }\n            if (transport === \"websocket\" && !upgrade) {\n                debug(\"invalid transport upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                });\n            }\n            if (!this.opts.allowRequest)\n                return fn();\n            return this.opts.allowRequest(req, (message, success) => {\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message,\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Adds a new middleware.\n     *\n     * @example\n     * import helmet from \"helmet\";\n     *\n     * engine.use(helmet());\n     *\n     * @param fn\n     */\n    use(fn) {\n        this.middlewares.push(fn);\n    }\n    /**\n     * Apply the middlewares to the request.\n     *\n     * @param req\n     * @param res\n     * @param callback\n     * @protected\n     */\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            debug(\"no middleware to apply, skipping\");\n            return callback();\n        }\n        const apply = (i) => {\n            debug(\"applying middleware n°%d\", i + 1);\n            this.middlewares[i](req, res, (err) => {\n                if (err) {\n                    return callback(err);\n                }\n                if (i + 1 < this.middlewares.length) {\n                    apply(i + 1);\n                }\n                else {\n                    callback();\n                }\n            });\n        };\n        apply(0);\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n    close() {\n        debug(\"closing all open clients\");\n        for (let i in this.clients) {\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        this.cleanup();\n        return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n    generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @param {Function} closeConnection\n     *\n     * @api protected\n     */\n    async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol,\n                },\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        }\n        catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e,\n                },\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = this.createTransport(transportName, req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            }\n            else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n            if (req._query && req._query.b64) {\n                transport.supportsBinary = false;\n            }\n            else {\n                transport.supportsBinary = true;\n            }\n        }\n        catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e,\n                },\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req) => {\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie),\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", () => {\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n        return transport;\n    }\n    async onWebTransportSession(session) {\n        const timeout = setTimeout(() => {\n            debug(\"the client failed to establish a bidirectional stream in the given period\");\n            session.close();\n        }, this.opts.upgradeTimeout);\n        const streamReader = session.incomingBidirectionalStreams.getReader();\n        const result = await streamReader.read();\n        if (result.done) {\n            debug(\"session is closed\");\n            return;\n        }\n        const stream = result.value;\n        const reader = stream.readable.getReader();\n        // reading the first packet of the stream\n        const { value, done } = await reader.read();\n        if (done) {\n            debug(\"stream is closed\");\n            return;\n        }\n        clearTimeout(timeout);\n        const handshake = TEXT_DECODER.decode(value);\n        // handshake is either\n        // \"0\" => new session\n        // '0{\"sid\":\"xxxx\"}' => upgrade\n        if (handshake === \"0\") {\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n            const id = base64id.generateId();\n            debug('handshaking client \"%s\" (WebTransport)', id);\n            const socket = new socket_1.Socket(id, this, transport, null, 4);\n            this.clients[id] = socket;\n            this.clientsCount++;\n            socket.once(\"close\", () => {\n                delete this.clients[id];\n                this.clientsCount--;\n            });\n            this.emit(\"connection\", socket);\n            return;\n        }\n        const sid = parseSessionId(handshake);\n        if (!sid) {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        const client = this.clients[sid];\n        if (!client) {\n            debug(\"upgrade attempt for closed client\");\n            session.close();\n        }\n        else if (client.upgrading) {\n            debug(\"transport has already been trying to upgrade\");\n            session.close();\n        }\n        else if (client.upgraded) {\n            debug(\"transport had already been upgraded\");\n            session.close();\n        }\n        else {\n            debug(\"upgrading existing transport\");\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            client.maybeUpgrade(transport);\n        }\n    }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */\nBaseServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5,\n};\nBaseServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\",\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\nclass WebSocketResponse {\n    constructor(req, socket) {\n        this.req = req;\n        this.socket = socket;\n        // temporarily store the response headers on the req object (see the \"headers\" event)\n        req[kResponseHeaders] = {};\n    }\n    setHeader(name, value) {\n        this.req[kResponseHeaders][name] = value;\n    }\n    getHeader(name) {\n        return this.req[kResponseHeaders][name];\n    }\n    removeHeader(name) {\n        delete this.req[kResponseHeaders][name];\n    }\n    write() { }\n    writeHead() { }\n    end() {\n        // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n        this.socket.destroy();\n    }\n}\nclass Server extends BaseServer {\n    /**\n     * Initialize websocket server\n     *\n     * @api protected\n     */\n    init() {\n        if (!~this.opts.transports.indexOf(\"websocket\"))\n            return;\n        if (this.ws)\n            this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize,\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req) => {\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = req[kResponseHeaders] || {};\n                delete req[kResponseHeaders];\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                debug(\"writing headers: %j\", additionalHeaders);\n                Object.keys(additionalHeaders).forEach((key) => {\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    cleanup() {\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n            // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n        }\n    }\n    createTransport(transportName, req) {\n        return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {IncomingMessage} req\n     * @param {ServerResponse} res\n     * @api public\n     */\n    handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        // @ts-ignore\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            // @ts-ignore\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                // @ts-ignore\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n                // @ts-ignore\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n    handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        const res = new WebSocketResponse(req, socket);\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead);\n            upgradeHead = null;\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            res.writeHead();\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, (websocket) => {\n                this.onWebSocket(req, socket, websocket);\n            });\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n    onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined &&\n            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            }\n            else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            }\n            else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            }\n            else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = this.createTransport(req._query.transport, req);\n                if (req._query && req._query.b64) {\n                    transport.supportsBinary = false;\n                }\n                else {\n                    transport.supportsBinary = true;\n                }\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n                client.maybeUpgrade(transport);\n            }\n        }\n        else {\n            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n            // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n    attach(server, options = {}) {\n        const path = this._computePath(options);\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        function check(req) {\n            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n            return path === req.url.slice(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res) => {\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            }\n            else {\n                let i = 0;\n                const l = listeners.length;\n                for (; i < l; i++) {\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head) => {\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                }\n                else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function () {\n                        // @ts-ignore\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            socket.on(\"error\", (e) => {\n                                debug(\"error while destroying upgrade: %s\", e.message);\n                            });\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\nfunction abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message\n        ? errorContext.message\n        : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message,\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", () => {\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" +\n            \"Connection: close\\r\\n\" +\n            \"Content-type: text/html\\r\\n\" +\n            \"Content-Length: \" +\n            length +\n            \"\\r\\n\" +\n            \"\\r\\n\" +\n            message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1)\n        return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2)\n        return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3)\n        return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4)\n        return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for (let i = 4; i < val.length; ++i) {\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,MAAM,GAAGF,OAAO,CAACG,UAAU,GAAG,KAAK,CAAC;AAC5C,MAAMC,EAAE,GAAGC,OAAO,CAAC,aAAa,CAAC;AACjC,MAAMC,KAAK,GAAGD,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAME,QAAQ,GAAGF,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMG,YAAY,GAAGH,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMK,QAAQ,GAAGL,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMM,OAAO,GAAGN,OAAO,CAAC,OAAO,CAAC;AAChC,MAAMO,QAAQ,GAAGP,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMQ,IAAI,GAAGR,OAAO,CAAC,IAAI,CAAC;AAC1B,MAAMS,cAAc,GAAGT,OAAO,CAAC,2BAA2B,CAAC;AAC3D,MAAMU,MAAM,GAAGV,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMW,KAAK,GAAG,CAAC,CAAC,EAAEL,OAAO,CAACM,OAAO,EAAE,QAAQ,CAAC;AAC5C,MAAMC,gBAAgB,GAAGC,MAAM,CAAC,iBAAiB,CAAC;AAClD,MAAMC,YAAY,GAAG,IAAIL,MAAM,CAACM,WAAW,CAAC,CAAC;AAC7C,SAASC,cAAcA,CAACC,SAAS,EAAE;EAC/B,IAAIA,SAAS,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAC5B,IAAI;MACA,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACJ,SAAS,CAACK,SAAS,CAAC,CAAC,CAAC,CAAC;MACjD,IAAI,OAAOH,MAAM,CAACI,GAAG,KAAK,QAAQ,EAAE;QAChC,OAAOJ,MAAM,CAACI,GAAG;MACrB;IACJ,CAAC,CACD,OAAOC,CAAC,EAAE,CAAE;EAChB;AACJ;AACA,MAAM3B,UAAU,SAASM,QAAQ,CAACsB,YAAY,CAAC;EAC3C;AACJ;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAAA,EAAY;IAAA,IAAXC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACjB,KAAK,CAAC,CAAC;IACP,IAAI,CAACG,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACN,IAAI,GAAGnC,MAAM,CAAC0C,MAAM,CAAC;MACtBC,QAAQ,EAAE5B,IAAI,CAACX,MAAM;MACrBwC,WAAW,EAAE,KAAK;MAClBC,YAAY,EAAE,KAAK;MACnBC,cAAc,EAAE,KAAK;MACrBC,iBAAiB,EAAE,GAAG;MACtBC,UAAU,EAAE,CAAC,SAAS,EAAE,WAAW,CAAC;MACpCC,aAAa,EAAE,IAAI;MACnBC,eAAe,EAAE;QACbC,SAAS,EAAE;MACf,CAAC;MACDC,IAAI,EAAE,KAAK;MACXC,SAAS,EAAE;IACf,CAAC,EAAElB,IAAI,CAAC;IACR,IAAIA,IAAI,CAACmB,MAAM,EAAE;MACb,IAAI,CAACnB,IAAI,CAACmB,MAAM,GAAGtD,MAAM,CAAC0C,MAAM,CAAC;QAC7Ba,IAAI,EAAE,IAAI;QACVC,IAAI,EAAE,GAAG;QACT;QACAC,QAAQ,EAAEtB,IAAI,CAACmB,MAAM,CAACE,IAAI,KAAK,KAAK;QACpCE,QAAQ,EAAE;MACd,CAAC,EAAEvB,IAAI,CAACmB,MAAM,CAAC;IACnB;IACA,IAAI,IAAI,CAACnB,IAAI,CAACiB,IAAI,EAAE;MAChB,IAAI,CAACO,GAAG,CAACpD,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC4B,IAAI,CAACiB,IAAI,CAAC,CAAC;IAC7C;IACA,IAAIjB,IAAI,CAACyB,iBAAiB,EAAE;MACxB,IAAI,CAACzB,IAAI,CAACyB,iBAAiB,GAAG5D,MAAM,CAAC0C,MAAM,CAAC;QACxCS,SAAS,EAAE;MACf,CAAC,EAAEhB,IAAI,CAACyB,iBAAiB,CAAC;IAC9B;IACA,IAAI,CAACC,IAAI,CAAC,CAAC;EACf;EACA;AACJ;AACA;AACA;AACA;EACIC,YAAYA,CAACC,OAAO,EAAE;IAClB,IAAIP,IAAI,GAAG,CAACO,OAAO,CAACP,IAAI,IAAI,YAAY,EAAEQ,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IAC5D,IAAID,OAAO,CAACE,gBAAgB,KAAK,KAAK,EAAE;MACpC;MACAT,IAAI,IAAI,GAAG;IACf;IACA,OAAOA,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIU,QAAQA,CAACC,SAAS,EAAE;IAChB,IAAI,CAAC,IAAI,CAAChC,IAAI,CAACc,aAAa,EACxB,OAAO,EAAE;IACb,OAAOvC,YAAY,CAACS,OAAO,CAACgD,SAAS,CAAC,CAACC,UAAU,IAAI,EAAE;EAC3D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACC,GAAG,EAAEC,OAAO,EAAEC,EAAE,EAAE;IACrB;IACA,MAAML,SAAS,GAAGG,GAAG,CAACG,MAAM,CAACN,SAAS;IACtC;IACA,IAAI,CAAC,CAAC,IAAI,CAAChC,IAAI,CAACa,UAAU,CAAC0B,OAAO,CAACP,SAAS,CAAC,IACzCA,SAAS,KAAK,cAAc,EAAE;MAC9BjD,KAAK,CAAC,wBAAwB,EAAEiD,SAAS,CAAC;MAC1C,OAAOK,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACC,iBAAiB,EAAE;QAAET;MAAU,CAAC,CAAC;IAC7D;IACA;IACA,MAAMU,eAAe,GAAGC,sBAAsB,CAACR,GAAG,CAACS,OAAO,CAACC,MAAM,CAAC;IAClE,IAAIH,eAAe,EAAE;MACjB,MAAMG,MAAM,GAAGV,GAAG,CAACS,OAAO,CAACC,MAAM;MACjCV,GAAG,CAACS,OAAO,CAACC,MAAM,GAAG,IAAI;MACzB9D,KAAK,CAAC,uBAAuB,CAAC;MAC9B,OAAOsD,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACM,WAAW,EAAE;QACjC1B,IAAI,EAAE,gBAAgB;QACtByB;MACJ,CAAC,CAAC;IACN;IACA;IACA,MAAMjD,GAAG,GAAGuC,GAAG,CAACG,MAAM,CAAC1C,GAAG;IAC1B,IAAIA,GAAG,EAAE;MACL,IAAI,CAAC,IAAI,CAACS,OAAO,CAAC0C,cAAc,CAACnD,GAAG,CAAC,EAAE;QACnCb,KAAK,CAAC,kBAAkB,EAAEa,GAAG,CAAC;QAC9B,OAAOyC,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACQ,WAAW,EAAE;UACjCpD;QACJ,CAAC,CAAC;MACN;MACA,MAAMqD,iBAAiB,GAAG,IAAI,CAAC5C,OAAO,CAACT,GAAG,CAAC,CAACoC,SAAS,CAACZ,IAAI;MAC1D,IAAI,CAACgB,OAAO,IAAIa,iBAAiB,KAAKjB,SAAS,EAAE;QAC7CjD,KAAK,CAAC,mDAAmD,CAAC;QAC1D,OAAOsD,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACM,WAAW,EAAE;UACjC1B,IAAI,EAAE,oBAAoB;UAC1BY,SAAS;UACTiB;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,MACI;MACD;MACA,IAAI,KAAK,KAAKd,GAAG,CAACe,MAAM,EAAE;QACtB,OAAOb,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACW,oBAAoB,EAAE;UAC1CD,MAAM,EAAEf,GAAG,CAACe;QAChB,CAAC,CAAC;MACN;MACA,IAAIlB,SAAS,KAAK,WAAW,IAAI,CAACI,OAAO,EAAE;QACvCrD,KAAK,CAAC,2BAA2B,CAAC;QAClC,OAAOsD,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACM,WAAW,EAAE;UACjC1B,IAAI,EAAE;QACV,CAAC,CAAC;MACN;MACA,IAAI,CAAC,IAAI,CAACpB,IAAI,CAACoD,YAAY,EACvB,OAAOf,EAAE,CAAC,CAAC;MACf,OAAO,IAAI,CAACrC,IAAI,CAACoD,YAAY,CAACjB,GAAG,EAAE,CAACkB,OAAO,EAAEC,OAAO,KAAK;QACrD,IAAI,CAACA,OAAO,EAAE;UACV,OAAOjB,EAAE,CAACpE,MAAM,CAACuE,MAAM,CAACe,SAAS,EAAE;YAC/BF;UACJ,CAAC,CAAC;QACN;QACAhB,EAAE,CAAC,CAAC;MACR,CAAC,CAAC;IACN;IACAA,EAAE,CAAC,CAAC;EACR;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIb,GAAGA,CAACa,EAAE,EAAE;IACJ,IAAI,CAACjC,WAAW,CAACoD,IAAI,CAACnB,EAAE,CAAC;EAC7B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIoB,iBAAiBA,CAACtB,GAAG,EAAEuB,GAAG,EAAEC,QAAQ,EAAE;IAClC,IAAI,IAAI,CAACvD,WAAW,CAACF,MAAM,KAAK,CAAC,EAAE;MAC/BnB,KAAK,CAAC,kCAAkC,CAAC;MACzC,OAAO4E,QAAQ,CAAC,CAAC;IACrB;IACA,MAAMC,KAAK,GAAIC,CAAC,IAAK;MACjB9E,KAAK,CAAC,0BAA0B,EAAE8E,CAAC,GAAG,CAAC,CAAC;MACxC,IAAI,CAACzD,WAAW,CAACyD,CAAC,CAAC,CAAC1B,GAAG,EAAEuB,GAAG,EAAGI,GAAG,IAAK;QACnC,IAAIA,GAAG,EAAE;UACL,OAAOH,QAAQ,CAACG,GAAG,CAAC;QACxB;QACA,IAAID,CAAC,GAAG,CAAC,GAAG,IAAI,CAACzD,WAAW,CAACF,MAAM,EAAE;UACjC0D,KAAK,CAACC,CAAC,GAAG,CAAC,CAAC;QAChB,CAAC,MACI;UACDF,QAAQ,CAAC,CAAC;QACd;MACJ,CAAC,CAAC;IACN,CAAC;IACDC,KAAK,CAAC,CAAC,CAAC;EACZ;EACA;AACJ;AACA;AACA;AACA;EACIG,KAAKA,CAAA,EAAG;IACJhF,KAAK,CAAC,0BAA0B,CAAC;IACjC,KAAK,IAAI8E,CAAC,IAAI,IAAI,CAACxD,OAAO,EAAE;MACxB,IAAI,IAAI,CAACA,OAAO,CAAC0C,cAAc,CAACc,CAAC,CAAC,EAAE;QAChC,IAAI,CAACxD,OAAO,CAACwD,CAAC,CAAC,CAACE,KAAK,CAAC,IAAI,CAAC;MAC/B;IACJ;IACA,IAAI,CAACC,OAAO,CAAC,CAAC;IACd,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAAC9B,GAAG,EAAE;IACZ,OAAO7D,QAAQ,CAAC2F,UAAU,CAAC,CAAC;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM3E,SAASA,CAAC4E,aAAa,EAAE/B,GAAG,EAAEgC,eAAe,EAAE;IACjD,MAAMC,QAAQ,GAAGjC,GAAG,CAACG,MAAM,CAAC+B,GAAG,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IACjD,IAAID,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,CAACpE,IAAI,CAACkB,SAAS,EAAE;MACxCnC,KAAK,CAAC,8BAA8B,CAAC;MACrC,IAAI,CAACuF,IAAI,CAAC,kBAAkB,EAAE;QAC1BnC,GAAG;QACHoC,IAAI,EAAEtG,MAAM,CAACuE,MAAM,CAACgC,4BAA4B;QAChDnB,OAAO,EAAEpF,MAAM,CAACwG,aAAa,CAACxG,MAAM,CAACuE,MAAM,CAACgC,4BAA4B,CAAC;QACzEE,OAAO,EAAE;UACLN;QACJ;MACJ,CAAC,CAAC;MACFD,eAAe,CAAClG,MAAM,CAACuE,MAAM,CAACgC,4BAA4B,CAAC;MAC3D;IACJ;IACA,IAAIG,EAAE;IACN,IAAI;MACAA,EAAE,GAAG,MAAM,IAAI,CAACV,UAAU,CAAC9B,GAAG,CAAC;IACnC,CAAC,CACD,OAAOtC,CAAC,EAAE;MACNd,KAAK,CAAC,8BAA8B,CAAC;MACrC,IAAI,CAACuF,IAAI,CAAC,kBAAkB,EAAE;QAC1BnC,GAAG;QACHoC,IAAI,EAAEtG,MAAM,CAACuE,MAAM,CAACM,WAAW;QAC/BO,OAAO,EAAEpF,MAAM,CAACwG,aAAa,CAACxG,MAAM,CAACuE,MAAM,CAACM,WAAW,CAAC;QACxD4B,OAAO,EAAE;UACLtD,IAAI,EAAE,qBAAqB;UAC3BwD,KAAK,EAAE/E;QACX;MACJ,CAAC,CAAC;MACFsE,eAAe,CAAClG,MAAM,CAACuE,MAAM,CAACM,WAAW,CAAC;MAC1C;IACJ;IACA/D,KAAK,CAAC,yBAAyB,EAAE4F,EAAE,CAAC;IACpC,IAAI;MACA,IAAI3C,SAAS,GAAG,IAAI,CAAC6C,eAAe,CAACX,aAAa,EAAE/B,GAAG,CAAC;MACxD,IAAI,SAAS,KAAK+B,aAAa,EAAE;QAC7BlC,SAAS,CAACpB,iBAAiB,GAAG,IAAI,CAACZ,IAAI,CAACY,iBAAiB;QACzDoB,SAAS,CAACjB,eAAe,GAAG,IAAI,CAACf,IAAI,CAACe,eAAe;MACzD,CAAC,MACI,IAAI,WAAW,KAAKmD,aAAa,EAAE;QACpClC,SAAS,CAACP,iBAAiB,GAAG,IAAI,CAACzB,IAAI,CAACyB,iBAAiB;MAC7D;MACA,IAAIU,GAAG,CAACG,MAAM,IAAIH,GAAG,CAACG,MAAM,CAACwC,GAAG,EAAE;QAC9B9C,SAAS,CAAC+C,cAAc,GAAG,KAAK;MACpC,CAAC,MACI;QACD/C,SAAS,CAAC+C,cAAc,GAAG,IAAI;MACnC;IACJ,CAAC,CACD,OAAOlF,CAAC,EAAE;MACNd,KAAK,CAAC,qCAAqC,EAAEmF,aAAa,CAAC;MAC3D,IAAI,CAACI,IAAI,CAAC,kBAAkB,EAAE;QAC1BnC,GAAG;QACHoC,IAAI,EAAEtG,MAAM,CAACuE,MAAM,CAACM,WAAW;QAC/BO,OAAO,EAAEpF,MAAM,CAACwG,aAAa,CAACxG,MAAM,CAACuE,MAAM,CAACM,WAAW,CAAC;QACxD4B,OAAO,EAAE;UACLtD,IAAI,EAAE,2BAA2B;UACjCwD,KAAK,EAAE/E;QACX;MACJ,CAAC,CAAC;MACFsE,eAAe,CAAClG,MAAM,CAACuE,MAAM,CAACM,WAAW,CAAC;MAC1C;IACJ;IACA,MAAMkC,MAAM,GAAG,IAAIvG,QAAQ,CAACwG,MAAM,CAACN,EAAE,EAAE,IAAI,EAAE3C,SAAS,EAAEG,GAAG,EAAEiC,QAAQ,CAAC;IACtEpC,SAAS,CAACkD,EAAE,CAAC,SAAS,EAAE,CAACtC,OAAO,EAAET,GAAG,KAAK;MACtC,MAAMgD,gBAAgB,GAAG,CAAChD,GAAG,CAACG,MAAM,CAAC1C,GAAG;MACxC,IAAIuF,gBAAgB,EAAE;QAClB,IAAI,IAAI,CAACnF,IAAI,CAACmB,MAAM,EAAE;UAClByB,OAAO,CAAC,YAAY,CAAC,GAAG;UACpB;UACA,CAAC,CAAC,EAAEjE,QAAQ,CAACyG,SAAS,EAAE,IAAI,CAACpF,IAAI,CAACmB,MAAM,CAACC,IAAI,EAAEuD,EAAE,EAAE,IAAI,CAAC3E,IAAI,CAACmB,MAAM,CAAC,CACvE;QACL;QACA,IAAI,CAACmD,IAAI,CAAC,iBAAiB,EAAE1B,OAAO,EAAET,GAAG,CAAC;MAC9C;MACA,IAAI,CAACmC,IAAI,CAAC,SAAS,EAAE1B,OAAO,EAAET,GAAG,CAAC;IACtC,CAAC,CAAC;IACFH,SAAS,CAACqD,SAAS,CAAClD,GAAG,CAAC;IACxB,IAAI,CAAC9B,OAAO,CAACsE,EAAE,CAAC,GAAGK,MAAM;IACzB,IAAI,CAAC1E,YAAY,EAAE;IACnB0E,MAAM,CAACM,IAAI,CAAC,OAAO,EAAE,MAAM;MACvB,OAAO,IAAI,CAACjF,OAAO,CAACsE,EAAE,CAAC;MACvB,IAAI,CAACrE,YAAY,EAAE;IACvB,CAAC,CAAC;IACF,IAAI,CAACgE,IAAI,CAAC,YAAY,EAAEU,MAAM,CAAC;IAC/B,OAAOhD,SAAS;EACpB;EACA,MAAMuD,qBAAqBA,CAACC,OAAO,EAAE;IACjC,MAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;MAC7B3G,KAAK,CAAC,2EAA2E,CAAC;MAClFyG,OAAO,CAACzB,KAAK,CAAC,CAAC;IACnB,CAAC,EAAE,IAAI,CAAC/D,IAAI,CAACW,cAAc,CAAC;IAC5B,MAAMgF,YAAY,GAAGH,OAAO,CAACI,4BAA4B,CAACC,SAAS,CAAC,CAAC;IACrE,MAAMC,MAAM,GAAG,MAAMH,YAAY,CAACI,IAAI,CAAC,CAAC;IACxC,IAAID,MAAM,CAACE,IAAI,EAAE;MACbjH,KAAK,CAAC,mBAAmB,CAAC;MAC1B;IACJ;IACA,MAAMkH,MAAM,GAAGH,MAAM,CAAC9H,KAAK;IAC3B,MAAMkI,MAAM,GAAGD,MAAM,CAACE,QAAQ,CAACN,SAAS,CAAC,CAAC;IAC1C;IACA,MAAM;MAAE7H,KAAK;MAAEgI;IAAK,CAAC,GAAG,MAAME,MAAM,CAACH,IAAI,CAAC,CAAC;IAC3C,IAAIC,IAAI,EAAE;MACNjH,KAAK,CAAC,kBAAkB,CAAC;MACzB;IACJ;IACAqH,YAAY,CAACX,OAAO,CAAC;IACrB,MAAMnG,SAAS,GAAGH,YAAY,CAACkH,MAAM,CAACrI,KAAK,CAAC;IAC5C;IACA;IACA;IACA,IAAIsB,SAAS,KAAK,GAAG,EAAE;MACnB,MAAM0C,SAAS,GAAG,IAAInD,cAAc,CAACyH,YAAY,CAACd,OAAO,EAAES,MAAM,EAAEC,MAAM,CAAC;MAC1E;MACA,MAAMvB,EAAE,GAAGrG,QAAQ,CAAC2F,UAAU,CAAC,CAAC;MAChClF,KAAK,CAAC,wCAAwC,EAAE4F,EAAE,CAAC;MACnD,MAAMK,MAAM,GAAG,IAAIvG,QAAQ,CAACwG,MAAM,CAACN,EAAE,EAAE,IAAI,EAAE3C,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;MAChE,IAAI,CAAC3B,OAAO,CAACsE,EAAE,CAAC,GAAGK,MAAM;MACzB,IAAI,CAAC1E,YAAY,EAAE;MACnB0E,MAAM,CAACM,IAAI,CAAC,OAAO,EAAE,MAAM;QACvB,OAAO,IAAI,CAACjF,OAAO,CAACsE,EAAE,CAAC;QACvB,IAAI,CAACrE,YAAY,EAAE;MACvB,CAAC,CAAC;MACF,IAAI,CAACgE,IAAI,CAAC,YAAY,EAAEU,MAAM,CAAC;MAC/B;IACJ;IACA,MAAMpF,GAAG,GAAGP,cAAc,CAACC,SAAS,CAAC;IACrC,IAAI,CAACM,GAAG,EAAE;MACNb,KAAK,CAAC,gCAAgC,CAAC;MACvC,OAAOyG,OAAO,CAACzB,KAAK,CAAC,CAAC;IAC1B;IACA,MAAMwC,MAAM,GAAG,IAAI,CAAClG,OAAO,CAACT,GAAG,CAAC;IAChC,IAAI,CAAC2G,MAAM,EAAE;MACTxH,KAAK,CAAC,mCAAmC,CAAC;MAC1CyG,OAAO,CAACzB,KAAK,CAAC,CAAC;IACnB,CAAC,MACI,IAAIwC,MAAM,CAACC,SAAS,EAAE;MACvBzH,KAAK,CAAC,8CAA8C,CAAC;MACrDyG,OAAO,CAACzB,KAAK,CAAC,CAAC;IACnB,CAAC,MACI,IAAIwC,MAAM,CAACE,QAAQ,EAAE;MACtB1H,KAAK,CAAC,qCAAqC,CAAC;MAC5CyG,OAAO,CAACzB,KAAK,CAAC,CAAC;IACnB,CAAC,MACI;MACDhF,KAAK,CAAC,8BAA8B,CAAC;MACrC,MAAMiD,SAAS,GAAG,IAAInD,cAAc,CAACyH,YAAY,CAACd,OAAO,EAAES,MAAM,EAAEC,MAAM,CAAC;MAC1EK,MAAM,CAACG,YAAY,CAAC1E,SAAS,CAAC;IAClC;EACJ;AACJ;AACAjE,OAAO,CAACG,UAAU,GAAGA,UAAU;AAC/B;AACA;AACA;AACAA,UAAU,CAACsE,MAAM,GAAG;EAChBC,iBAAiB,EAAE,CAAC;EACpBO,WAAW,EAAE,CAAC;EACdG,oBAAoB,EAAE,CAAC;EACvBL,WAAW,EAAE,CAAC;EACdS,SAAS,EAAE,CAAC;EACZiB,4BAA4B,EAAE;AAClC,CAAC;AACDtG,UAAU,CAACuG,aAAa,GAAG;EACvB,CAAC,EAAE,mBAAmB;EACtB,CAAC,EAAE,oBAAoB;EACvB,CAAC,EAAE,sBAAsB;EACzB,CAAC,EAAE,aAAa;EAChB,CAAC,EAAE,WAAW;EACd,CAAC,EAAE;AACP,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMkC,iBAAiB,CAAC;EACpB5G,WAAWA,CAACoC,GAAG,EAAE6C,MAAM,EAAE;IACrB,IAAI,CAAC7C,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC6C,MAAM,GAAGA,MAAM;IACpB;IACA7C,GAAG,CAAClD,gBAAgB,CAAC,GAAG,CAAC,CAAC;EAC9B;EACA2H,SAASA,CAACxF,IAAI,EAAEpD,KAAK,EAAE;IACnB,IAAI,CAACmE,GAAG,CAAClD,gBAAgB,CAAC,CAACmC,IAAI,CAAC,GAAGpD,KAAK;EAC5C;EACA6I,SAASA,CAACzF,IAAI,EAAE;IACZ,OAAO,IAAI,CAACe,GAAG,CAAClD,gBAAgB,CAAC,CAACmC,IAAI,CAAC;EAC3C;EACA0F,YAAYA,CAAC1F,IAAI,EAAE;IACf,OAAO,IAAI,CAACe,GAAG,CAAClD,gBAAgB,CAAC,CAACmC,IAAI,CAAC;EAC3C;EACA2F,KAAKA,CAAA,EAAG,CAAE;EACVC,SAASA,CAAA,EAAG,CAAE;EACdC,GAAGA,CAAA,EAAG;IACF;IACA,IAAI,CAACjC,MAAM,CAACkC,OAAO,CAAC,CAAC;EACzB;AACJ;AACA,MAAMjJ,MAAM,SAASC,UAAU,CAAC;EAC5B;AACJ;AACA;AACA;AACA;EACIwD,IAAIA,CAAA,EAAG;IACH,IAAI,CAAC,CAAC,IAAI,CAAC1B,IAAI,CAACa,UAAU,CAAC0B,OAAO,CAAC,WAAW,CAAC,EAC3C;IACJ,IAAI,IAAI,CAAC4E,EAAE,EACP,IAAI,CAACA,EAAE,CAACpD,KAAK,CAAC,CAAC;IACnB,IAAI,CAACoD,EAAE,GAAG,IAAI,IAAI,CAACnH,IAAI,CAACQ,QAAQ,CAAC;MAC7B4G,QAAQ,EAAE,IAAI;MACdC,cAAc,EAAE,KAAK;MACrB5F,iBAAiB,EAAE,IAAI,CAACzB,IAAI,CAACyB,iBAAiB;MAC9C6F,UAAU,EAAE,IAAI,CAACtH,IAAI,CAACY;IAC1B,CAAC,CAAC;IACF,IAAI,OAAO,IAAI,CAACuG,EAAE,CAACjC,EAAE,KAAK,UAAU,EAAE;MAClC,IAAI,CAACiC,EAAE,CAACjC,EAAE,CAAC,SAAS,EAAE,CAACqC,YAAY,EAAEpF,GAAG,KAAK;QACzC;QACA;QACA,MAAMqF,iBAAiB,GAAGrF,GAAG,CAAClD,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACrD,OAAOkD,GAAG,CAAClD,gBAAgB,CAAC;QAC5B,MAAMkG,gBAAgB,GAAG,CAAChD,GAAG,CAACG,MAAM,CAAC1C,GAAG;QACxC,IAAIuF,gBAAgB,EAAE;UAClB,IAAI,CAACb,IAAI,CAAC,iBAAiB,EAAEkD,iBAAiB,EAAErF,GAAG,CAAC;QACxD;QACA,IAAI,CAACmC,IAAI,CAAC,SAAS,EAAEkD,iBAAiB,EAAErF,GAAG,CAAC;QAC5CpD,KAAK,CAAC,qBAAqB,EAAEyI,iBAAiB,CAAC;QAC/C3J,MAAM,CAAC4J,IAAI,CAACD,iBAAiB,CAAC,CAACE,OAAO,CAAEC,GAAG,IAAK;UAC5CJ,YAAY,CAAC/D,IAAI,CAAE,GAAEmE,GAAI,KAAIH,iBAAiB,CAACG,GAAG,CAAE,EAAC,CAAC;QAC1D,CAAC,CAAC;MACN,CAAC,CAAC;IACN;EACJ;EACA3D,OAAOA,CAAA,EAAG;IACN,IAAI,IAAI,CAACmD,EAAE,EAAE;MACTpI,KAAK,CAAC,yBAAyB,CAAC;MAChC,IAAI,CAACoI,EAAE,CAACpD,KAAK,CAAC,CAAC;MACf;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI6D,OAAOA,CAACzF,GAAG,EAAE;IACT;IACA,IAAI,CAACA,GAAG,CAACG,MAAM,EAAE;MACbH,GAAG,CAACG,MAAM,GAAG,CAACH,GAAG,CAAC0F,GAAG,CAACtF,OAAO,CAAC,GAAG,CAAC,GAAGpE,EAAE,CAACuB,KAAK,CAAC,CAAC,CAAC,EAAErB,KAAK,CAACqB,KAAK,EAAEyC,GAAG,CAAC0F,GAAG,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC;IACvF;EACJ;EACAjD,eAAeA,CAACX,aAAa,EAAE/B,GAAG,EAAE;IAChC,OAAO,IAAI5D,YAAY,CAACS,OAAO,CAACkF,aAAa,CAAC,CAAC/B,GAAG,CAAC;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI4F,aAAaA,CAAC5F,GAAG,EAAEuB,GAAG,EAAE;IACpB3E,KAAK,CAAC,iCAAiC,EAAEoD,GAAG,CAACe,MAAM,EAAEf,GAAG,CAAC0F,GAAG,CAAC;IAC7D,IAAI,CAACD,OAAO,CAACzF,GAAG,CAAC;IACjB;IACAA,GAAG,CAACuB,GAAG,GAAGA,GAAG;IACb,MAAMC,QAAQ,GAAGA,CAACqE,SAAS,EAAEC,YAAY,KAAK;MAC1C,IAAID,SAAS,KAAK7H,SAAS,EAAE;QACzB,IAAI,CAACmE,IAAI,CAAC,kBAAkB,EAAE;UAC1BnC,GAAG;UACHoC,IAAI,EAAEyD,SAAS;UACf3E,OAAO,EAAEpF,MAAM,CAACwG,aAAa,CAACuD,SAAS,CAAC;UACxCtD,OAAO,EAAEuD;QACb,CAAC,CAAC;QACFC,YAAY,CAACxE,GAAG,EAAEsE,SAAS,EAAEC,YAAY,CAAC;QAC1C;MACJ;MACA;MACA,IAAI9F,GAAG,CAACG,MAAM,CAAC1C,GAAG,EAAE;QAChBb,KAAK,CAAC,yCAAyC,CAAC;QAChD;QACA,IAAI,CAACsB,OAAO,CAAC8B,GAAG,CAACG,MAAM,CAAC1C,GAAG,CAAC,CAACoC,SAAS,CAACqD,SAAS,CAAClD,GAAG,CAAC;MACzD,CAAC,MACI;QACD,MAAMgC,eAAe,GAAGA,CAAC6D,SAAS,EAAEC,YAAY,KAAKC,YAAY,CAACxE,GAAG,EAAEsE,SAAS,EAAEC,YAAY,CAAC;QAC/F;QACA,IAAI,CAAC3I,SAAS,CAAC6C,GAAG,CAACG,MAAM,CAACN,SAAS,EAAEG,GAAG,EAAEgC,eAAe,CAAC;MAC9D;IACJ,CAAC;IACD,IAAI,CAACV,iBAAiB,CAACtB,GAAG,EAAEuB,GAAG,EAAGI,GAAG,IAAK;MACtC,IAAIA,GAAG,EAAE;QACLH,QAAQ,CAAC1F,MAAM,CAACuE,MAAM,CAACM,WAAW,EAAE;UAAE1B,IAAI,EAAE;QAAqB,CAAC,CAAC;MACvE,CAAC,MACI;QACD,IAAI,CAACc,MAAM,CAACC,GAAG,EAAE,KAAK,EAAEwB,QAAQ,CAAC;MACrC;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACIwE,aAAaA,CAAChG,GAAG,EAAE6C,MAAM,EAAEoD,WAAW,EAAE;IACpC,IAAI,CAACR,OAAO,CAACzF,GAAG,CAAC;IACjB,MAAMuB,GAAG,GAAG,IAAIiD,iBAAiB,CAACxE,GAAG,EAAE6C,MAAM,CAAC;IAC9C,MAAMrB,QAAQ,GAAGA,CAACqE,SAAS,EAAEC,YAAY,KAAK;MAC1C,IAAID,SAAS,KAAK7H,SAAS,EAAE;QACzB,IAAI,CAACmE,IAAI,CAAC,kBAAkB,EAAE;UAC1BnC,GAAG;UACHoC,IAAI,EAAEyD,SAAS;UACf3E,OAAO,EAAEpF,MAAM,CAACwG,aAAa,CAACuD,SAAS,CAAC;UACxCtD,OAAO,EAAEuD;QACb,CAAC,CAAC;QACFI,YAAY,CAACrD,MAAM,EAAEgD,SAAS,EAAEC,YAAY,CAAC;QAC7C;MACJ;MACA,MAAMK,IAAI,GAAGC,MAAM,CAACC,IAAI,CAACJ,WAAW,CAAC;MACrCA,WAAW,GAAG,IAAI;MAClB;MACA;MACA1E,GAAG,CAACsD,SAAS,CAAC,CAAC;MACf;MACA,IAAI,CAACG,EAAE,CAACgB,aAAa,CAAChG,GAAG,EAAE6C,MAAM,EAAEsD,IAAI,EAAGG,SAAS,IAAK;QACpD,IAAI,CAACC,WAAW,CAACvG,GAAG,EAAE6C,MAAM,EAAEyD,SAAS,CAAC;MAC5C,CAAC,CAAC;IACN,CAAC;IACD,IAAI,CAAChF,iBAAiB,CAACtB,GAAG,EAAEuB,GAAG,EAAGI,GAAG,IAAK;MACtC,IAAIA,GAAG,EAAE;QACLH,QAAQ,CAAC1F,MAAM,CAACuE,MAAM,CAACM,WAAW,EAAE;UAAE1B,IAAI,EAAE;QAAqB,CAAC,CAAC;MACvE,CAAC,MACI;QACD,IAAI,CAACc,MAAM,CAACC,GAAG,EAAE,IAAI,EAAEwB,QAAQ,CAAC;MACpC;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;EACI+E,WAAWA,CAACvG,GAAG,EAAE6C,MAAM,EAAEyD,SAAS,EAAE;IAChCA,SAAS,CAACvD,EAAE,CAAC,OAAO,EAAEyD,cAAc,CAAC;IACrC,IAAIpK,YAAY,CAACS,OAAO,CAACmD,GAAG,CAACG,MAAM,CAACN,SAAS,CAAC,KAAK7B,SAAS,IACxD,CAAC5B,YAAY,CAACS,OAAO,CAACmD,GAAG,CAACG,MAAM,CAACN,SAAS,CAAC,CAAC4G,SAAS,CAACC,eAAe,EAAE;MACvE9J,KAAK,CAAC,2CAA2C,CAAC;MAClD0J,SAAS,CAAC1E,KAAK,CAAC,CAAC;MACjB;IACJ;IACA;IACA,MAAMY,EAAE,GAAGxC,GAAG,CAACG,MAAM,CAAC1C,GAAG;IACzB;IACAuC,GAAG,CAACsG,SAAS,GAAGA,SAAS;IACzB,IAAI9D,EAAE,EAAE;MACJ,MAAM4B,MAAM,GAAG,IAAI,CAAClG,OAAO,CAACsE,EAAE,CAAC;MAC/B,IAAI,CAAC4B,MAAM,EAAE;QACTxH,KAAK,CAAC,mCAAmC,CAAC;QAC1C0J,SAAS,CAAC1E,KAAK,CAAC,CAAC;MACrB,CAAC,MACI,IAAIwC,MAAM,CAACC,SAAS,EAAE;QACvBzH,KAAK,CAAC,8CAA8C,CAAC;QACrD0J,SAAS,CAAC1E,KAAK,CAAC,CAAC;MACrB,CAAC,MACI,IAAIwC,MAAM,CAACE,QAAQ,EAAE;QACtB1H,KAAK,CAAC,qCAAqC,CAAC;QAC5C0J,SAAS,CAAC1E,KAAK,CAAC,CAAC;MACrB,CAAC,MACI;QACDhF,KAAK,CAAC,8BAA8B,CAAC;QACrC;QACA0J,SAAS,CAACK,cAAc,CAAC,OAAO,EAAEH,cAAc,CAAC;QACjD,MAAM3G,SAAS,GAAG,IAAI,CAAC6C,eAAe,CAAC1C,GAAG,CAACG,MAAM,CAACN,SAAS,EAAEG,GAAG,CAAC;QACjE,IAAIA,GAAG,CAACG,MAAM,IAAIH,GAAG,CAACG,MAAM,CAACwC,GAAG,EAAE;UAC9B9C,SAAS,CAAC+C,cAAc,GAAG,KAAK;QACpC,CAAC,MACI;UACD/C,SAAS,CAAC+C,cAAc,GAAG,IAAI;QACnC;QACA/C,SAAS,CAACP,iBAAiB,GAAG,IAAI,CAACzB,IAAI,CAACyB,iBAAiB;QACzD8E,MAAM,CAACG,YAAY,CAAC1E,SAAS,CAAC;MAClC;IACJ,CAAC,MACI;MACD,MAAMmC,eAAe,GAAGA,CAAC6D,SAAS,EAAEC,YAAY,KAAKI,YAAY,CAACrD,MAAM,EAAEgD,SAAS,EAAEC,YAAY,CAAC;MAClG,IAAI,CAAC3I,SAAS,CAAC6C,GAAG,CAACG,MAAM,CAACN,SAAS,EAAEG,GAAG,EAAEgC,eAAe,CAAC;IAC9D;IACA,SAASwE,cAAcA,CAAA,EAAG;MACtB5J,KAAK,CAAC,gCAAgC,CAAC;MACvC;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIgK,MAAMA,CAACC,MAAM,EAAgB;IAAA,IAAdpH,OAAO,GAAA3B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACvB,MAAMoB,IAAI,GAAG,IAAI,CAACM,YAAY,CAACC,OAAO,CAAC;IACvC,MAAMqH,qBAAqB,GAAGrH,OAAO,CAACqH,qBAAqB,IAAI,IAAI;IACnE,SAASC,KAAKA,CAAC/G,GAAG,EAAE;MAChB;MACA,OAAOd,IAAI,KAAKc,GAAG,CAAC0F,GAAG,CAACsB,KAAK,CAAC,CAAC,EAAE9H,IAAI,CAACnB,MAAM,CAAC;IACjD;IACA;IACA,MAAMkJ,SAAS,GAAGJ,MAAM,CAACI,SAAS,CAAC,SAAS,CAAC,CAACD,KAAK,CAAC,CAAC,CAAC;IACtDH,MAAM,CAACK,kBAAkB,CAAC,SAAS,CAAC;IACpCL,MAAM,CAAC9D,EAAE,CAAC,OAAO,EAAE,IAAI,CAACnB,KAAK,CAACuF,IAAI,CAAC,IAAI,CAAC,CAAC;IACzCN,MAAM,CAAC9D,EAAE,CAAC,WAAW,EAAE,IAAI,CAACxD,IAAI,CAAC4H,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5C;IACAN,MAAM,CAAC9D,EAAE,CAAC,SAAS,EAAE,CAAC/C,GAAG,EAAEuB,GAAG,KAAK;MAC/B,IAAIwF,KAAK,CAAC/G,GAAG,CAAC,EAAE;QACZpD,KAAK,CAAC,oCAAoC,EAAEsC,IAAI,CAAC;QACjD,IAAI,CAAC0G,aAAa,CAAC5F,GAAG,EAAEuB,GAAG,CAAC;MAChC,CAAC,MACI;QACD,IAAIG,CAAC,GAAG,CAAC;QACT,MAAM0F,CAAC,GAAGH,SAAS,CAAClJ,MAAM;QAC1B,OAAO2D,CAAC,GAAG0F,CAAC,EAAE1F,CAAC,EAAE,EAAE;UACfuF,SAAS,CAACvF,CAAC,CAAC,CAAC2F,IAAI,CAACR,MAAM,EAAE7G,GAAG,EAAEuB,GAAG,CAAC;QACvC;MACJ;IACJ,CAAC,CAAC;IACF,IAAI,CAAC,IAAI,CAAC1D,IAAI,CAACa,UAAU,CAAC0B,OAAO,CAAC,WAAW,CAAC,EAAE;MAC5CyG,MAAM,CAAC9D,EAAE,CAAC,SAAS,EAAE,CAAC/C,GAAG,EAAE6C,MAAM,EAAEsD,IAAI,KAAK;QACxC,IAAIY,KAAK,CAAC/G,GAAG,CAAC,EAAE;UACZ,IAAI,CAACgG,aAAa,CAAChG,GAAG,EAAE6C,MAAM,EAAEsD,IAAI,CAAC;QACzC,CAAC,MACI,IAAI,KAAK,KAAK1G,OAAO,CAAC6H,cAAc,EAAE;UACvC;UACA;UACA;UACA;UACA/D,UAAU,CAAC,YAAY;YACnB;YACA,IAAIV,MAAM,CAAC0E,QAAQ,IAAI1E,MAAM,CAAC2E,YAAY,IAAI,CAAC,EAAE;cAC7C3E,MAAM,CAACE,EAAE,CAAC,OAAO,EAAGrF,CAAC,IAAK;gBACtBd,KAAK,CAAC,oCAAoC,EAAEc,CAAC,CAACwD,OAAO,CAAC;cAC1D,CAAC,CAAC;cACF,OAAO2B,MAAM,CAACiC,GAAG,CAAC,CAAC;YACvB;UACJ,CAAC,EAAEgC,qBAAqB,CAAC;QAC7B;MACJ,CAAC,CAAC;IACN;EACJ;AACJ;AACAlL,OAAO,CAACE,MAAM,GAAGA,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiK,YAAYA,CAACxE,GAAG,EAAEsE,SAAS,EAAEC,YAAY,EAAE;EAChD,MAAM2B,UAAU,GAAG5B,SAAS,KAAK/J,MAAM,CAACuE,MAAM,CAACe,SAAS,GAAG,GAAG,GAAG,GAAG;EACpE,MAAMF,OAAO,GAAG4E,YAAY,IAAIA,YAAY,CAAC5E,OAAO,GAC9C4E,YAAY,CAAC5E,OAAO,GACpBpF,MAAM,CAACwG,aAAa,CAACuD,SAAS,CAAC;EACrCtE,GAAG,CAACsD,SAAS,CAAC4C,UAAU,EAAE;IAAE,cAAc,EAAE;EAAmB,CAAC,CAAC;EACjElG,GAAG,CAACuD,GAAG,CAACxH,IAAI,CAACoK,SAAS,CAAC;IACnBtF,IAAI,EAAEyD,SAAS;IACf3E;EACJ,CAAC,CAAC,CAAC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgF,YAAYA,CAACrD,MAAM,EAAEgD,SAAS,EAAqB;EAAA,IAAnBC,YAAY,GAAAhI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACtD+E,MAAM,CAACE,EAAE,CAAC,OAAO,EAAE,MAAM;IACrBnG,KAAK,CAAC,uCAAuC,CAAC;EAClD,CAAC,CAAC;EACF,IAAIiG,MAAM,CAAC0E,QAAQ,EAAE;IACjB,MAAMrG,OAAO,GAAG4E,YAAY,CAAC5E,OAAO,IAAIpF,MAAM,CAACwG,aAAa,CAACuD,SAAS,CAAC;IACvE,MAAM9H,MAAM,GAAGqI,MAAM,CAACuB,UAAU,CAACzG,OAAO,CAAC;IACzC2B,MAAM,CAAC+B,KAAK,CAAC,8BAA8B,GACvC,uBAAuB,GACvB,6BAA6B,GAC7B,kBAAkB,GAClB7G,MAAM,GACN,MAAM,GACN,MAAM,GACNmD,OAAO,CAAC;EAChB;EACA2B,MAAM,CAACkC,OAAO,CAAC,CAAC;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM6C,aAAa,GAAG,CAClB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAC9C,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,CAClD;;AACD,SAASpH,sBAAsBA,CAACqH,GAAG,EAAE;EACjCA,GAAG,IAAI,EAAE;EACT,IAAIA,GAAG,CAAC9J,MAAM,GAAG,CAAC,EACd,OAAO,KAAK;EAChB,IAAI,CAAC6J,aAAa,CAACC,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;IACnClL,KAAK,CAAC,oCAAoC,EAAEiL,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAI;EACf;EACA,IAAID,GAAG,CAAC9J,MAAM,GAAG,CAAC,EACd,OAAO,KAAK;EAChB,IAAI,CAAC6J,aAAa,CAACC,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;IACnClL,KAAK,CAAC,oCAAoC,EAAEiL,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAI;EACf;EACA,IAAID,GAAG,CAAC9J,MAAM,GAAG,CAAC,EACd,OAAO,KAAK;EAChB,IAAI,CAAC6J,aAAa,CAACC,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;IACnClL,KAAK,CAAC,oCAAoC,EAAEiL,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAI;EACf;EACA,IAAID,GAAG,CAAC9J,MAAM,GAAG,CAAC,EACd,OAAO,KAAK;EAChB,IAAI,CAAC6J,aAAa,CAACC,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;IACnClL,KAAK,CAAC,oCAAoC,EAAEiL,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAI;EACf;EACA,KAAK,IAAIpG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmG,GAAG,CAAC9J,MAAM,EAAE,EAAE2D,CAAC,EAAE;IACjC,IAAI,CAACkG,aAAa,CAACC,GAAG,CAACC,UAAU,CAACpG,CAAC,CAAC,CAAC,EAAE;MACnC9E,KAAK,CAAC,uCAAuC,EAAE8E,CAAC,EAAEmG,GAAG,CAACC,UAAU,CAACpG,CAAC,CAAC,CAAC;MACpE,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}