{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_1 = require(\"./socket\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nclass BroadcastOperator {\n  constructor(adapter) {\n    let rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    let exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    let flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.adapter = adapter;\n    this.rooms = rooms;\n    this.exceptRooms = exceptRooms;\n    this.flags = flags;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @example\n   * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n   * io.to(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   * // with an array of rooms (a client will be notified at most once)\n   * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   * // with multiple chained calls\n   * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  to(room) {\n    const rooms = new Set(this.rooms);\n    if (Array.isArray(room)) {\n      room.forEach(r => rooms.add(r));\n    } else {\n      rooms.add(room);\n    }\n    return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n  }\n  /**\n   * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n   *\n   * @example\n   * // disconnect all clients in the \"room-101\" room\n   * io.in(\"room-101\").disconnectSockets();\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  in(room) {\n    return this.to(room);\n  }\n  /**\n   * Excludes a room when emitting.\n   *\n   * @example\n   * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n   * io.except(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   * // with an array of rooms\n   * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   * // with multiple chained calls\n   * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  except(room) {\n    const exceptRooms = new Set(this.exceptRooms);\n    if (Array.isArray(room)) {\n      room.forEach(r => exceptRooms.add(r));\n    } else {\n      exceptRooms.add(room);\n    }\n    return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @example\n   * io.compress(false).emit(\"hello\");\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return a new BroadcastOperator instance\n   */\n  compress(compress) {\n    const flags = Object.assign({}, this.flags, {\n      compress\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @example\n   * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n   *\n   * @return a new BroadcastOperator instance\n   */\n  get volatile() {\n    const flags = Object.assign({}, this.flags, {\n      volatile: true\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @example\n   * // the “foo” event will be broadcast to all connected clients on this node\n   * io.local.emit(\"foo\", \"bar\");\n   *\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  get local() {\n    const flags = Object.assign({}, this.flags, {\n      local: true\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Adds a timeout in milliseconds for the next operation\n   *\n   * @example\n   * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n   *   if (err) {\n   *     // some clients did not acknowledge the event in the given delay\n   *   } else {\n   *     console.log(responses); // one response per client\n   *   }\n   * });\n   *\n   * @param timeout\n   */\n  timeout(timeout) {\n    const flags = Object.assign({}, this.flags, {\n      timeout\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Emits to all clients.\n   *\n   * @example\n   * // the “foo” event will be broadcast to all connected clients\n   * io.emit(\"foo\", \"bar\");\n   *\n   * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n   * io.to(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   * // with an acknowledgement expected from all connected clients\n   * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n   *   if (err) {\n   *     // some clients did not acknowledge the event in the given delay\n   *   } else {\n   *     console.log(responses); // one response per client\n   *   }\n   * });\n   *\n   * @return Always true\n   */\n  emit(ev) {\n    if (socket_1.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${String(ev)}\" is a reserved event name`);\n    }\n    // set up packet object\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const data = [ev, ...args];\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: data\n    };\n    const withAck = typeof data[data.length - 1] === \"function\";\n    if (!withAck) {\n      this.adapter.broadcast(packet, {\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      });\n      return true;\n    }\n    const ack = data.pop();\n    let timedOut = false;\n    let responses = [];\n    const timer = setTimeout(() => {\n      timedOut = true;\n      ack.apply(this, [new Error(\"operation has timed out\"), this.flags.expectSingleResponse ? null : responses]);\n    }, this.flags.timeout);\n    let expectedServerCount = -1;\n    let actualServerCount = 0;\n    let expectedClientCount = 0;\n    const checkCompleteness = () => {\n      if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n        clearTimeout(timer);\n        ack.apply(this, [null, this.flags.expectSingleResponse ? null : responses]);\n      }\n    };\n    this.adapter.broadcastWithAck(packet, {\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    }, clientCount => {\n      // each Socket.IO server in the cluster sends the number of clients that were notified\n      expectedClientCount += clientCount;\n      actualServerCount++;\n      checkCompleteness();\n    }, clientResponse => {\n      // each client sends an acknowledgement\n      responses.push(clientResponse);\n      checkCompleteness();\n    });\n    this.adapter.serverCount().then(serverCount => {\n      expectedServerCount = serverCount;\n      checkCompleteness();\n    });\n    return true;\n  }\n  /**\n   * Emits an event and waits for an acknowledgement from all clients.\n   *\n   * @example\n   * try {\n   *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n   *   console.log(responses); // one response per client\n   * } catch (e) {\n   *   // some clients did not acknowledge the event in the given delay\n   * }\n   *\n   * @return a Promise that will be fulfilled when all clients have acknowledged the event\n   */\n  emitWithAck(ev) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return new Promise((resolve, reject) => {\n      args.push((err, responses) => {\n        if (err) {\n          err.responses = responses;\n          return reject(err);\n        } else {\n          return resolve(responses);\n        }\n      });\n      this.emit(ev, ...args);\n    });\n  }\n  /**\n   * Gets a list of clients.\n   *\n   * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n   * {@link fetchSockets} instead.\n   */\n  allSockets() {\n    if (!this.adapter) {\n      throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n    }\n    return this.adapter.sockets(this.rooms);\n  }\n  /**\n   * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n   *\n   * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n   *\n   * @example\n   * // return all Socket instances\n   * const sockets = await io.fetchSockets();\n   *\n   * // return all Socket instances in the \"room1\" room\n   * const sockets = await io.in(\"room1\").fetchSockets();\n   *\n   * for (const socket of sockets) {\n   *   console.log(socket.id);\n   *   console.log(socket.handshake);\n   *   console.log(socket.rooms);\n   *   console.log(socket.data);\n   *\n   *   socket.emit(\"hello\");\n   *   socket.join(\"room1\");\n   *   socket.leave(\"room2\");\n   *   socket.disconnect();\n   * }\n   */\n  fetchSockets() {\n    return this.adapter.fetchSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    }).then(sockets => {\n      return sockets.map(socket => {\n        if (socket instanceof socket_1.Socket) {\n          // FIXME the TypeScript compiler complains about missing private properties\n          return socket;\n        } else {\n          return new RemoteSocket(this.adapter, socket);\n        }\n      });\n    });\n  }\n  /**\n   * Makes the matching socket instances join the specified rooms.\n   *\n   * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n   *\n   * @example\n   *\n   * // make all socket instances join the \"room1\" room\n   * io.socketsJoin(\"room1\");\n   *\n   * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n   * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n   *\n   * @param room - a room, or an array of rooms\n   */\n  socketsJoin(room) {\n    this.adapter.addSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    }, Array.isArray(room) ? room : [room]);\n  }\n  /**\n   * Makes the matching socket instances leave the specified rooms.\n   *\n   * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n   *\n   * @example\n   * // make all socket instances leave the \"room1\" room\n   * io.socketsLeave(\"room1\");\n   *\n   * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n   * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n   *\n   * @param room - a room, or an array of rooms\n   */\n  socketsLeave(room) {\n    this.adapter.delSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    }, Array.isArray(room) ? room : [room]);\n  }\n  /**\n   * Makes the matching socket instances disconnect.\n   *\n   * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n   *\n   * @example\n   * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n   * io.disconnectSockets();\n   *\n   * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n   * io.in(\"room1\").disconnectSockets(true);\n   *\n   * @param close - whether to close the underlying connection\n   */\n  disconnectSockets() {\n    let close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.adapter.disconnectSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    }, close);\n  }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n  constructor(adapter, details) {\n    this.id = details.id;\n    this.handshake = details.handshake;\n    this.rooms = new Set(details.rooms);\n    this.data = details.data;\n    this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {\n      expectSingleResponse: true // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()\n    });\n  }\n  /**\n   * Adds a timeout in milliseconds for the next operation.\n   *\n   * @example\n   * const sockets = await io.fetchSockets();\n   *\n   * for (const socket of sockets) {\n   *   if (someCondition) {\n   *     socket.timeout(1000).emit(\"some-event\", (err) => {\n   *       if (err) {\n   *         // the client did not acknowledge the event in the given delay\n   *       }\n   *     });\n   *   }\n   * }\n   *\n   * // note: if possible, using a room instead of looping over all sockets is preferable\n   * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n   *   // ...\n   * });\n   *\n   * @param timeout\n   */\n  timeout(timeout) {\n    return this.operator.timeout(timeout);\n  }\n  emit(ev) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.operator.emit(ev, ...args);\n  }\n  /**\n   * Joins a room.\n   *\n   * @param {String|Array} room - room or array of rooms\n   */\n  join(room) {\n    return this.operator.socketsJoin(room);\n  }\n  /**\n   * Leaves a room.\n   *\n   * @param {String} room\n   */\n  leave(room) {\n    return this.operator.socketsLeave(room);\n  }\n  /**\n   * Disconnects this client.\n   *\n   * @param {Boolean} close - if `true`, closes the underlying connection\n   * @return {Socket} self\n   */\n  disconnect() {\n    let close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.operator.disconnectSockets(close);\n    return this;\n  }\n}\nexports.RemoteSocket = RemoteSocket;","map":{"version":3,"names":["Object","defineProperty","exports","value","RemoteSocket","BroadcastOperator","socket_1","require","socket_io_parser_1","constructor","adapter","rooms","arguments","length","undefined","Set","exceptRooms","flags","to","room","Array","isArray","forEach","r","add","in","except","compress","assign","volatile","local","timeout","emit","ev","RESERVED_EVENTS","has","Error","String","_len","args","_key","data","packet","type","PacketType","EVENT","withAck","broadcast","ack","pop","timedOut","responses","timer","setTimeout","apply","expectSingleResponse","expectedServerCount","actualServerCount","expectedClientCount","checkCompleteness","clearTimeout","broadcastWithAck","clientCount","clientResponse","push","serverCount","then","emitWithAck","_len2","_key2","Promise","resolve","reject","err","allSockets","sockets","fetchSockets","map","socket","Socket","socketsJoin","addSockets","socketsLeave","delSockets","disconnectSockets","close","details","id","handshake","operator","_len3","_key3","join","leave","disconnect"],"sources":["/home/priyanshu/Desktop/rebook/main/reactapp/node_modules/socket.io/dist/broadcast-operator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_1 = require(\"./socket\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => rooms.add(r));\n        }\n        else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => exceptRooms.add(r));\n        }\n        else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */\n    compress(compress) {\n        const flags = Object.assign({}, this.flags, { compress });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */\n    get volatile() {\n        const flags = Object.assign({}, this.flags, { volatile: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        const flags = Object.assign({}, this.flags, { local: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        const flags = Object.assign({}, this.flags, { timeout });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the “foo” event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the “foo” event will be broadcast to all connected clients in the “room-101” room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */\n    emit(ev, ...args) {\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags,\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(() => {\n            timedOut = true;\n            ack.apply(this, [\n                new Error(\"operation has timed out\"),\n                this.flags.expectSingleResponse ? null : responses,\n            ]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = () => {\n            if (!timedOut &&\n                expectedServerCount === actualServerCount &&\n                responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [\n                    null,\n                    this.flags.expectSingleResponse ? null : responses,\n                ]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, (clientCount) => {\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse) => {\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount) => {\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement from all clients.\n     *\n     * @example\n     * try {\n     *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n     *   console.log(responses); // one response per client\n     * } catch (e) {\n     *   // some clients did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when all clients have acknowledged the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            args.push((err, responses) => {\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                }\n                else {\n                    return resolve(responses);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */\n    fetchSockets() {\n        return this.adapter\n            .fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        })\n            .then((sockets) => {\n            return sockets.map((socket) => {\n                if (socket instanceof socket_1.Socket) {\n                    // FIXME the TypeScript compiler complains about missing private properties\n                    return socket;\n                }\n                else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */\n    socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n    constructor(adapter, details) {\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {\n            expectSingleResponse: true, // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()\n        });\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const sockets = await io.fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   if (someCondition) {\n     *     socket.timeout(1000).emit(\"some-event\", (err) => {\n     *       if (err) {\n     *         // the client did not acknowledge the event in the given delay\n     *       }\n     *     });\n     *   }\n     * }\n     *\n     * // note: if possible, using a room instead of looping over all sockets is preferable\n     * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        return this.operator.timeout(timeout);\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */\n    join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */\n    leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */\n    disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}